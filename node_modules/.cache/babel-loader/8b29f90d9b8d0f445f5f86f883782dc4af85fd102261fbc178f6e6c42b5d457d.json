{"ast":null,"code":"import * as d3 from 'd3';\nimport { find_path } from 'dijkstrajs';\nimport { colors } from '../config/config';\nexport const findShortestPath = (graph, system1, system2, highlightPath) => {\n  if (system1 === 'rect1' || system2 === 'rect1') {\n    console.error('Invalid system selection for pathfinding:', system1, system2);\n    return;\n  }\n  const graphNodes = {};\n  graph.edges.forEach(edge => {\n    if (!graphNodes[edge.start]) graphNodes[edge.start] = {};\n    if (!graphNodes[edge.end]) graphNodes[edge.end] = {};\n    graphNodes[edge.start][edge.end] = edge.distance;\n    graphNodes[edge.end][edge.start] = edge.distance;\n  });\n  try {\n    const path = find_path(graphNodes, system1, system2);\n    console.log('Found Path:', path);\n    highlightPath(path, system2);\n  } catch (error) {\n    console.error('Error finding path:', error);\n  }\n};\n\n// Function to reset all nodes and paths\nexport const resetGraphState = nextSelectedSystem => {\n  // Reset all system nodes color and stroke except the background rect and current selection\n  d3.selectAll('rect').each(function () {\n    const systemId = d3.select(this).attr('id');\n    if (systemId !== 'rect1' && systemId !== nextSelectedSystem) {\n      d3.select(this).attr('fill', colors.resetSystemFill).attr('fill-opacity', colors.resetSystemFillOpacity).attr('stroke', colors.resetSystemStroke).attr('stroke-width', colors.resetSystemStrokeWidth);\n    }\n  });\n\n  // Reset all paths color and stroke\n  d3.selectAll('path').each(function () {\n    d3.select(this).attr('stroke', colors.resetPathStroke).attr('stroke-width', colors.resetPathStrokeWidth);\n  });\n};\n\n// Function to highlight the path\nexport const highlightPath = (path, systemSelected) => {\n  // Reset all system nodes color and stroke except the background rect\n  resetGraphState(systemSelected);\n\n  // Highlight systems in the path\n  path.forEach(system => {\n    d3.select(`#${CSS.escape(system)}`).attr('fill', colors.systemFill).attr('stroke', colors.systemStroke);\n  });\n\n  // Highlight paths in the path\n  for (let i = 0; i < path.length - 1; i++) {\n    const start = path[i];\n    const end = path[i + 1];\n    d3.selectAll(`path[id*=\"${start}\"][id*=\"${end}\"], path[id*=\"${end}\"][id*=\"${start}\"]`).attr('stroke', colors.pathStroke).attr('stroke-width', colors.pathStrokeWidth);\n  }\n\n  // Ensure the start and end systems of the path are highlighted\n  if (path.length >= 2) {\n    const startSystem = path[0];\n    const endSystem = path[path.length - 1];\n    highlightSelectedSystem(null, startSystem, [startSystem, endSystem]);\n    highlightSelectedSystem(null, endSystem, [startSystem, endSystem]);\n  }\n};\nexport const highlightSelectedSystem = (prevSelectedSystem, nextSelectedSystem, pathfindingSelection, isPathfindingEnabled) => {\n  // Check if pathfindingSelection is empty, if so reset all nodes\n  if (pathfindingSelection.length < 2 && isPathfindingEnabled) {\n    resetGraphState(nextSelectedSystem);\n  }\n\n  // Reset previous system if it's not part of pathfinding selection\n  if (prevSelectedSystem && !pathfindingSelection.includes(prevSelectedSystem)) {\n    const prevSystemNode = d3.select(`#${CSS.escape(prevSelectedSystem)}`);\n    if (!prevSystemNode.empty()) {\n      prevSystemNode.attr('fill', colors.resetSystemFill).attr('fill-opacity', colors.resetSystemFillOpacity).attr('stroke', colors.resetSystemStroke).attr('stroke-width', colors.resetSystemStrokeWidth);\n    }\n  }\n\n  // Highlight new system\n  if (nextSelectedSystem) {\n    const nextSystemNode = d3.select(`#${CSS.escape(nextSelectedSystem)}`);\n    if (!nextSystemNode.empty()) {\n      nextSystemNode.attr('fill', colors.systemFill).attr('stroke', colors.systemStroke).attr('stroke-width', colors.systemStrokeWidth);\n    }\n  }\n};","map":{"version":3,"names":["d3","find_path","colors","findShortestPath","graph","system1","system2","highlightPath","console","error","graphNodes","edges","forEach","edge","start","end","distance","path","log","resetGraphState","nextSelectedSystem","selectAll","each","systemId","select","attr","resetSystemFill","resetSystemFillOpacity","resetSystemStroke","resetSystemStrokeWidth","resetPathStroke","resetPathStrokeWidth","systemSelected","system","CSS","escape","systemFill","systemStroke","i","length","pathStroke","pathStrokeWidth","startSystem","endSystem","highlightSelectedSystem","prevSelectedSystem","pathfindingSelection","isPathfindingEnabled","includes","prevSystemNode","empty","nextSystemNode","systemStrokeWidth"],"sources":["/home/admin_user/PycharmProjects/StarMap_PrUn/prun-universe-map/src/utils/graphUtils.js"],"sourcesContent":["import * as d3 from 'd3';\nimport { find_path } from 'dijkstrajs';\nimport { colors } from '../config/config';\n\nexport const findShortestPath = (graph, system1, system2, highlightPath) => {\n  if (system1 === 'rect1' || system2 === 'rect1') {\n    console.error('Invalid system selection for pathfinding:', system1, system2);\n    return;\n  }\n\n  const graphNodes = {};\n  graph.edges.forEach(edge => {\n    if (!graphNodes[edge.start]) graphNodes[edge.start] = {};\n    if (!graphNodes[edge.end]) graphNodes[edge.end] = {};\n    graphNodes[edge.start][edge.end] = edge.distance;\n    graphNodes[edge.end][edge.start] = edge.distance;\n  });\n\n  try {\n    const path = find_path(graphNodes, system1, system2);\n    console.log('Found Path:', path)\n    highlightPath(path, system2);\n  } catch (error) {\n    console.error('Error finding path:', error);\n  }\n};\n\n// Function to reset all nodes and paths\nexport const resetGraphState = (nextSelectedSystem) => {\n  // Reset all system nodes color and stroke except the background rect and current selection\n  d3.selectAll('rect').each(function() {\n    const systemId = d3.select(this).attr('id');\n    if (systemId !== 'rect1' && systemId !== nextSelectedSystem) {\n      d3.select(this)\n        .attr('fill', colors.resetSystemFill)\n        .attr('fill-opacity', colors.resetSystemFillOpacity)\n        .attr('stroke', colors.resetSystemStroke)\n        .attr('stroke-width', colors.resetSystemStrokeWidth);\n    }\n  });\n\n  // Reset all paths color and stroke\n  d3.selectAll('path').each(function() {\n    d3.select(this)\n      .attr('stroke', colors.resetPathStroke)\n      .attr('stroke-width', colors.resetPathStrokeWidth);\n  });\n};\n\n// Function to highlight the path\nexport const highlightPath = (path, systemSelected) => {\n  // Reset all system nodes color and stroke except the background rect\n  resetGraphState(systemSelected)\n\n  // Highlight systems in the path\n  path.forEach(system => {\n    d3.select(`#${CSS.escape(system)}`)\n      .attr('fill', colors.systemFill)\n      .attr('stroke', colors.systemStroke);\n  });\n\n  // Highlight paths in the path\n  for (let i = 0; i < path.length - 1; i++) {\n    const start = path[i];\n    const end = path[i + 1];\n\n    d3.selectAll(`path[id*=\"${start}\"][id*=\"${end}\"], path[id*=\"${end}\"][id*=\"${start}\"]`)\n      .attr('stroke', colors.pathStroke)\n      .attr('stroke-width', colors.pathStrokeWidth);\n  }\n\n  // Ensure the start and end systems of the path are highlighted\n  if (path.length >= 2) {\n    const startSystem = path[0];\n    const endSystem = path[path.length - 1];\n    highlightSelectedSystem(null, startSystem, [startSystem, endSystem]);\n    highlightSelectedSystem(null, endSystem, [startSystem, endSystem]);\n  }\n};\n\nexport const highlightSelectedSystem = (prevSelectedSystem, nextSelectedSystem, pathfindingSelection, isPathfindingEnabled) => {\n\n  // Check if pathfindingSelection is empty, if so reset all nodes\n  if (pathfindingSelection.length < 2 && isPathfindingEnabled) {\n    resetGraphState(nextSelectedSystem);\n  }\n\n  // Reset previous system if it's not part of pathfinding selection\n  if (prevSelectedSystem && !pathfindingSelection.includes(prevSelectedSystem)) {\n    const prevSystemNode = d3.select(`#${CSS.escape(prevSelectedSystem)}`);\n    if (!prevSystemNode.empty()) {\n      prevSystemNode\n        .attr('fill', colors.resetSystemFill)\n        .attr('fill-opacity', colors.resetSystemFillOpacity)\n        .attr('stroke', colors.resetSystemStroke)\n        .attr('stroke-width', colors.resetSystemStrokeWidth);\n    }\n  }\n\n  // Highlight new system\n  if (nextSelectedSystem) {\n    const nextSystemNode = d3.select(`#${CSS.escape(nextSelectedSystem)}`);\n    if (!nextSystemNode.empty()) {\n      nextSystemNode\n        .attr('fill', colors.systemFill)\n        .attr('stroke', colors.systemStroke)\n        .attr('stroke-width', colors.systemStrokeWidth);\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
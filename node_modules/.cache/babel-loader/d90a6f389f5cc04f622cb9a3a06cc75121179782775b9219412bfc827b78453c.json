{"ast":null,"code":"import * as d3 from 'd3';\nimport { find_path } from 'dijkstrajs';\nimport { colors } from '../config/config';\nexport const findShortestPath = (graph, system1, system2, highlightPath) => {\n  if (system1 === 'rect1' || system2 === 'rect1') {\n    console.error('Invalid system selection for pathfinding:', system1, system2);\n    return;\n  }\n  const graphNodes = {};\n  graph.edges.forEach(edge => {\n    if (!graphNodes[edge.start]) graphNodes[edge.start] = {};\n    if (!graphNodes[edge.end]) graphNodes[edge.end] = {};\n    graphNodes[edge.start][edge.end] = edge.distance;\n    graphNodes[edge.end][edge.start] = edge.distance;\n  });\n  try {\n    const path = find_path(graphNodes, system1, system2);\n    console.log('Found Path:', path);\n    highlightPath(path);\n  } catch (error) {\n    console.error('Error finding path:', error);\n  }\n};\n\n// Function to reset all nodes and paths\nexport const resetGraphState = nextSelectedSystem => {\n  // Reset all system nodes color and stroke except the background rect and current selection\n  d3.selectAll('rect').each(function () {\n    if (d3.select(this).attr('id') !== 'rect1') {\n      d3.select(this).attr('fill', colors.resetSystemFill).attr('fill-opacity', colors.resetSystemFillOpacity).attr('stroke', colors.resetSystemStroke).attr('stroke-width', colors.resetSystemStrokeWidth);\n    }\n  });\n\n  // Reset all paths color and stroke\n  d3.selectAll('path').each(function () {\n    d3.select(this).attr('stroke', colors.resetPathStroke).attr('stroke-width', colors.resetPathStrokeWidth);\n  });\n};\n\n// Function to highlight the path\nexport const highlightPath = path => {\n  // Reset all system nodes color and stroke except the background rect\n  resetGraphState();\n\n  // Highlight systems in the path\n  path.forEach(system => {\n    d3.select(`#${CSS.escape(system)}`).attr('fill', colors.systemFill).attr('stroke', colors.systemStroke);\n  });\n\n  // Highlight paths in the path\n  for (let i = 0; i < path.length - 1; i++) {\n    const start = path[i];\n    const end = path[i + 1];\n    d3.selectAll(`path[id*=\"${start}\"][id*=\"${end}\"], path[id*=\"${end}\"][id*=\"${start}\"]`).attr('stroke', colors.pathStroke).attr('stroke-width', colors.pathStrokeWidth);\n  }\n\n  // Ensure the start and end systems of the path are highlighted\n  if (path.length >= 2) {\n    const startSystem = path[0];\n    const endSystem = path[path.length - 1];\n    highlightSelectedSystem(null, startSystem, [startSystem, endSystem]);\n    highlightSelectedSystem(null, endSystem, [startSystem, endSystem]);\n  }\n};\nexport const highlightSelectedSystem = (prevSelectedSystem, nextSelectedSystem, pathfindingSelection, isPathfindingEnabled) => {\n  // Check if pathfindingSelection is empty, if so reset all nodes\n  if (pathfindingSelection.length < 2 && isPathfindingEnabled) {\n    resetGraphState(nextSelectedSystem);\n  }\n\n  // Reset previous system if it's not part of pathfinding selection\n  if (prevSelectedSystem && !pathfindingSelection.includes(prevSelectedSystem)) {\n    const prevSystemNode = d3.select(`#${CSS.escape(prevSelectedSystem)}`);\n    if (!prevSystemNode.empty()) {\n      prevSystemNode.attr('fill', colors.resetSystemFill).attr('fill-opacity', colors.resetSystemFillOpacity).attr('stroke', colors.resetSystemStroke).attr('stroke-width', colors.resetSystemStrokeWidth);\n    }\n  }\n\n  // Highlight new system\n  if (nextSelectedSystem) {\n    const nextSystemNode = d3.select(`#${CSS.escape(nextSelectedSystem)}`);\n    if (!nextSystemNode.empty()) {\n      nextSystemNode.attr('fill', colors.systemFill).attr('stroke', colors.systemStroke).attr('stroke-width', colors.systemStrokeWidth);\n    }\n  }\n};","map":{"version":3,"names":["d3","find_path","colors","findShortestPath","graph","system1","system2","highlightPath","console","error","graphNodes","edges","forEach","edge","start","end","distance","path","log","resetGraphState","nextSelectedSystem","selectAll","each","select","attr","resetSystemFill","resetSystemFillOpacity","resetSystemStroke","resetSystemStrokeWidth","resetPathStroke","resetPathStrokeWidth","system","CSS","escape","systemFill","systemStroke","i","length","pathStroke","pathStrokeWidth","startSystem","endSystem","highlightSelectedSystem","prevSelectedSystem","pathfindingSelection","isPathfindingEnabled","includes","prevSystemNode","empty","nextSystemNode","systemStrokeWidth"],"sources":["/home/admin_user/PycharmProjects/StarMap_PrUn/prun-universe-map/src/utils/graphUtils.js"],"sourcesContent":["import * as d3 from 'd3';\nimport { find_path } from 'dijkstrajs';\nimport { colors } from '../config/config';\n\nexport const findShortestPath = (graph, system1, system2, highlightPath) => {\n  if (system1 === 'rect1' || system2 === 'rect1') {\n    console.error('Invalid system selection for pathfinding:', system1, system2);\n    return;\n  }\n\n  const graphNodes = {};\n  graph.edges.forEach(edge => {\n    if (!graphNodes[edge.start]) graphNodes[edge.start] = {};\n    if (!graphNodes[edge.end]) graphNodes[edge.end] = {};\n    graphNodes[edge.start][edge.end] = edge.distance;\n    graphNodes[edge.end][edge.start] = edge.distance;\n  });\n\n  try {\n    const path = find_path(graphNodes, system1, system2);\n    console.log('Found Path:', path)\n    highlightPath(path);\n  } catch (error) {\n    console.error('Error finding path:', error);\n  }\n};\n\n// Function to reset all nodes and paths\nexport const resetGraphState = (nextSelectedSystem) => {\n  // Reset all system nodes color and stroke except the background rect and current selection\n  d3.selectAll('rect').each(function() {\n    if (d3.select(this).attr('id') !== 'rect1') {\n      d3.select(this)\n        .attr('fill', colors.resetSystemFill)\n        .attr('fill-opacity', colors.resetSystemFillOpacity)\n        .attr('stroke', colors.resetSystemStroke)\n        .attr('stroke-width', colors.resetSystemStrokeWidth);\n    }\n  });\n\n  // Reset all paths color and stroke\n  d3.selectAll('path').each(function() {\n    d3.select(this)\n      .attr('stroke', colors.resetPathStroke)\n      .attr('stroke-width', colors.resetPathStrokeWidth);\n  });\n};\n\n// Function to highlight the path\nexport const highlightPath = (path) => {\n  // Reset all system nodes color and stroke except the background rect\n  resetGraphState()\n\n  // Highlight systems in the path\n  path.forEach(system => {\n    d3.select(`#${CSS.escape(system)}`)\n      .attr('fill', colors.systemFill)\n      .attr('stroke', colors.systemStroke);\n  });\n\n  // Highlight paths in the path\n  for (let i = 0; i < path.length - 1; i++) {\n    const start = path[i];\n    const end = path[i + 1];\n\n    d3.selectAll(`path[id*=\"${start}\"][id*=\"${end}\"], path[id*=\"${end}\"][id*=\"${start}\"]`)\n      .attr('stroke', colors.pathStroke)\n      .attr('stroke-width', colors.pathStrokeWidth);\n  }\n\n  // Ensure the start and end systems of the path are highlighted\n  if (path.length >= 2) {\n    const startSystem = path[0];\n    const endSystem = path[path.length - 1];\n    highlightSelectedSystem(null, startSystem, [startSystem, endSystem]);\n    highlightSelectedSystem(null, endSystem, [startSystem, endSystem]);\n  }\n};\n\nexport const highlightSelectedSystem = (prevSelectedSystem, nextSelectedSystem, pathfindingSelection, isPathfindingEnabled) => {\n\n  // Check if pathfindingSelection is empty, if so reset all nodes\n  if (pathfindingSelection.length < 2 && isPathfindingEnabled) {\n    resetGraphState(nextSelectedSystem);\n  }\n\n  // Reset previous system if it's not part of pathfinding selection\n  if (prevSelectedSystem && !pathfindingSelection.includes(prevSelectedSystem)) {\n    const prevSystemNode = d3.select(`#${CSS.escape(prevSelectedSystem)}`);\n    if (!prevSystemNode.empty()) {\n      prevSystemNode\n        .attr('fill', colors.resetSystemFill)\n        .attr('fill-opacity', colors.resetSystemFillOpacity)\n        .attr('stroke', colors.resetSystemStroke)\n        .attr('stroke-width', colors.resetSystemStrokeWidth);\n    }\n  }\n\n  // Highlight new system\n  if (nextSelectedSystem) {\n    const nextSystemNode = d3.select(`#${CSS.escape(nextSelectedSystem)}`);\n    if (!nextSystemNode.empty()) {\n      nextSystemNode\n        .attr('fill', colors.systemFill)\n        .attr('stroke', colors.systemStroke)\n        .attr('stroke-width', colors.systemStrokeWidth);\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}